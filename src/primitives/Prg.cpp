#include "../../include/primitives/Prg.hpp"

void ScPrgFromPrf::setKey(SecretKey secretKey) {
	prf->setKey(secretKey); //Sets the key to the underlying prf.
	
	ctr = vector<byte>(prf->getBlockSize());
	// Initializes the counter to 1.
	ctr[ctr.size() - 1] = 1;
	this->_isKeySet = true;
}

void ScPrgFromPrf::getPRGBytes(vector<byte> & outBytes, int outOffset, int outLen) {
	if (!isKeySet())
		throw IllegalStateException("secret key isn't set");

	int numGeneratedBytes = 0;	// Number of current generated bytes.
	vector<byte> generatedBytes = vector<byte>(ctr.size());

	while (numGeneratedBytes < outLen) {
		try {
			// If the prf can output any length (for example, IteratedPrfVarying) call the computeBlock with the outputLen.
			prf->computeBlock(ctr, 0, ctr.size(), outBytes, outOffset + numGeneratedBytes, outLen);
			numGeneratedBytes += outLen;
		}
		catch (out_of_range& e) {
			try {
				// if the prf can receive any input length (for example, Hmac) call the computeBlock with the ctr length.
				// the output is written to a new array because there is no guarantee that output array is long enough to hold the next output block.
				prf->computeBlock(ctr, 0, ctr.size(), generatedBytes, 0);
				//Copy the right number of generated bytes.
				if (numGeneratedBytes + generatedBytes.size() <= outLen)
					outBytes.insert(outBytes.begin() + outOffset + numGeneratedBytes, generatedBytes.begin(), generatedBytes.end());
				else
					outBytes.insert(outBytes.begin() + outOffset + numGeneratedBytes, generatedBytes.begin(), generatedBytes.begin() + (outLen - numGeneratedBytes));

				// increases the number of generated bytes.
				numGeneratedBytes += ctr.size();
			}
			catch (out_of_range& e1) {
				try {
					// if the prf can receive fixed input length (for example, AES) call the computeBlock without the input length.
					// the output is written to a new array because there is no guarantee that output array is long enough to hold the next output block.
					prf->computeBlock(ctr, 0, generatedBytes, 0);
					// copy the right number of generated bytes.
					if (numGeneratedBytes + generatedBytes.size() <= outLen) 
						outBytes.insert(outBytes.begin() + outOffset + numGeneratedBytes, generatedBytes.begin(), generatedBytes.end());
					else 
						outBytes.insert(outBytes.begin() + outOffset + numGeneratedBytes, generatedBytes.begin(), generatedBytes.begin()+(outLen - numGeneratedBytes)); 
					// increases the number of generated bytes.
					numGeneratedBytes += ctr.size();
				}
				catch (out_of_range& e3) {
					cerr << e3.what() << endl;
					return;
				}
			}
		}
		// increases the counter.
		increaseCtr();
	}
}

void ScPrgFromPrf::increaseCtr() {
	//increase the counter by one.
	int carry = 1;
	int len = ctr.size();
	for (int i = len - 1; i >= 0; i--)
	{
		int x = (ctr[i] & 0xff) + carry;
		if (x > 0xff)
			carry = 1;
		else
			carry = 0;
		ctr[i] = (byte)x;
	}
}

void OpenSSLRC4::setKey(SecretKey secretKey) {
	vector<byte> encodedKey = secretKey.getEncoded();
	RC4_set_key(rc4, encodedKey.size(), &encodedKey[0]); 	// set the key to the openssl object.
	_isKeySet = true; // marks this object as initialized.
	vector<byte> out(128); // RC4 has a problem in the first 1024 bits. by ignoring these bytes, we bypass this problem.
	getPRGBytes(out, 0, 128);
}

SecretKey OpenSSLRC4::generateKey(int keySize) {
	// generate a random string of bits of length keySize, which has to be greater that zero. 
	// if the key size is zero or less - throw exception
	if (keySize <= 0)
		throw invalid_argument("key size must be greater than 0");

	// the key size has to be a multiple of 8 so that we can obtain an array of random bytes which we use
	// to create the SecretKey.
	if ((keySize % 8) != 0) 
		throw invalid_argument("Wrong key size: must be a multiple of 8");
	
	vector<byte> genBytes;
	gen_random_bytes_vector(genBytes, keySize / 8, random);

	// creates a secretKey from the generated bytes.
	SecretKey generatedKey(genBytes, "");
	return generatedKey;
}

void OpenSSLRC4::getPRGBytes(vector<byte> & outBytes, int outOffset, int outLen) {
	if (!isKeySet())
		throw IllegalStateException("secret key isn't set");
	
	// create an input array full with zeros. (It will be xored with the pseudo random bytes in order to get the generated bytes).
	unsigned char* in = (unsigned char*)calloc(outLen, sizeof(char));

	// prepare the output array.
	unsigned char* output = new unsigned char[outLen];

	// generate the pseudo random bytes.
	::RC4(rc4, outLen, in, output);

	//Copy the output bytes to the given output array.
	copy_byte_array_to_byte_vector(output, outLen, outBytes, 0);

	// release the allocated memory.
	free(in);
	delete output;
}

OpenSSLRC4::~OpenSSLRC4() {
	delete rc4;
}